/* test this with:
bagof(X,p(X),L),length(L,X).
to count number of solutions. Without cuts:
r -> 3, 
s->2,
q -> 3*3 + 3*2 = 15,
p -> 15*3*2 = 90 solutions generated by backtracking without cut
*/
p( p(X,Y,Z) ) :- q(X) , r(Y), s(Z).
/* insert !,    ^      ^     ^   ^  */

q( q(X,Y) ) :- r(X), r(Y) .
/* insert !,  ^     ^    ^ */
q( q2(X,Y) ) :- r(X), s(Y) .
/* insert !,   ^     ^    ^ */


r(a).
r(b).
r(c).

s(t).
s(u).

% negation by failure . equivalent to built-in not(Clause) 
mynot(P) :- P , !, fail.
mynot(_) :- true.

intersect(set([]), _, set([])).
% if head of first list is a member of second, include in the result
intersect(set([HA|RA]), set(B), set([HA|Result])) :- member(HA, B), 
	intersect(set(RA), set(B), set(Result)).
% if head of first list is not a member of second, include in the result
intersect(set([HA|RA]), set(B), set(Result)) :- mynot(member(HA, B)), 
	intersect(set(RA), set(B), set(Result)).

%%% or simply use a cut ! in first clause when member succeeds
intersect2(set([]), _, set([])).
% if head of first list is a member of second, include in the result
intersect2(set([HA|RA]), set(B), set([HA|Result])) :- member(HA, B), !,
	intersect2(set(RA), set(B), set(Result)).
% if head of first list is not a member of second, include in the result
intersect2(set([HA|RA]), set(B), set(Result)) :-
	intersect2(set(RA), set(B), set(Result)).
